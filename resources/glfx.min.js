var fx=function(){var R={};(function(){function t(r){if(!r.getExtension("OES_texture_float"))return!1;var c=r.createFramebuffer(),d=r.createTexture();r.bindTexture(r.TEXTURE_2D,d),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_MAG_FILTER,r.NEAREST),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_MIN_FILTER,r.NEAREST),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_WRAP_S,r.CLAMP_TO_EDGE),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_WRAP_T,r.CLAMP_TO_EDGE),r.texImage2D(r.TEXTURE_2D,0,r.RGBA,1,1,0,r.RGBA,r.UNSIGNED_BYTE,null),r.bindFramebuffer(r.FRAMEBUFFER,c),r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,d,0);var b=[2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],E=r.createTexture();r.bindTexture(r.TEXTURE_2D,E),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_MAG_FILTER,r.LINEAR),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_MIN_FILTER,r.LINEAR),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_WRAP_S,r.CLAMP_TO_EDGE),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_WRAP_T,r.CLAMP_TO_EDGE),r.texImage2D(r.TEXTURE_2D,0,r.RGBA,2,2,0,r.RGBA,r.FLOAT,new Float32Array(b));var v=r.createProgram(),_=r.createShader(r.VERTEX_SHADER),p=r.createShader(r.FRAGMENT_SHADER);r.shaderSource(_,"      attribute vec2 vertex;      void main() {        gl_Position = vec4(vertex, 0.0, 1.0);      }    "),r.shaderSource(p,"      uniform sampler2D texture;      void main() {        gl_FragColor = texture2D(texture, vec2(0.5));      }    "),r.compileShader(_),r.compileShader(p),r.attachShader(v,_),r.attachShader(v,p),r.linkProgram(v);var y=r.createBuffer();r.bindBuffer(r.ARRAY_BUFFER,y),r.bufferData(r.ARRAY_BUFFER,new Float32Array([0,0]),r.STREAM_DRAW),r.enableVertexAttribArray(0),r.vertexAttribPointer(0,2,r.FLOAT,!1,0,0);var A=new Uint8Array(4);return r.useProgram(v),r.viewport(0,0,1,1),r.bindTexture(r.TEXTURE_2D,E),r.drawArrays(r.POINTS,0,1),r.readPixels(0,0,1,1,r.RGBA,r.UNSIGNED_BYTE,A),A[0]===127||A[0]===128}function o(){}function a(r){return r.$OES_texture_float_linear$===void 0&&Object.defineProperty(r,"$OES_texture_float_linear$",{enumerable:!1,configurable:!1,writable:!1,value:new o}),r.$OES_texture_float_linear$}function i(r){return r==="OES_texture_float_linear"?a(this):l.call(this,r)}function n(){var r=s.call(this);return r.indexOf("OES_texture_float_linear")===-1&&r.push("OES_texture_float_linear"),r}try{var u=document.createElement("canvas").getContext("webgl2")}catch{}if(!(!u||u.getSupportedExtensions().indexOf("OES_texture_float_linear")!==-1)&&t(u)){var l=WebGLRenderingContext.prototype.getExtension,s=WebGLRenderingContext.prototype.getSupportedExtensions;WebGLRenderingContext.prototype.getExtension=i,WebGLRenderingContext.prototype.getSupportedExtensions=n}})();function C(t,o){return new h(null,t+"    uniform sampler2D texture;    uniform vec2 texSize;    varying vec2 texCoord;    void main() {        vec2 coord = texCoord * texSize;        "+o+"        gl_FragColor = texture2D(texture, coord / texSize);        vec2 clampedCoord = clamp(coord, vec2(0.0), texSize);        if (coord != clampedCoord) {            /* fade to transparent if we are outside the image */            gl_FragColor.a *= max(0.0, 1.0 - length(coord - clampedCoord));        }    }")}var g="    float random(vec3 scale, float seed) {        /* use the fragment position for a different seed per-pixel */        return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);    }";function U(t){return e.sepia=e.sepia||new h(null,"        uniform sampler2D texture;        uniform float amount;        varying vec2 texCoord;        void main() {            vec4 color = texture2D(texture, texCoord);            float r = color.r;            float g = color.g;            float b = color.b;                        color.r = min(1.0, (r * (1.0 - (0.607 * amount))) + (g * (0.769 * amount)) + (b * (0.189 * amount)));            color.g = min(1.0, (r * 0.349 * amount) + (g * (1.0 - (0.314 * amount))) + (b * 0.168 * amount));            color.b = min(1.0, (r * 0.272 * amount) + (g * 0.534 * amount) + (b * (1.0 - (0.869 * amount))));                        gl_FragColor = color;        }    "),f.call(this,e.sepia,{amount:m(0,t,1)}),this}function P(t){e.denoise=e.denoise||new h(null,"        uniform sampler2D texture;        uniform float exponent;        uniform float strength;        uniform vec2 texSize;        varying vec2 texCoord;        void main() {            vec4 center = texture2D(texture, texCoord);            vec4 color = vec4(0.0);            float total = 0.0;            for (float x = -4.0; x <= 4.0; x += 1.0) {                for (float y = -4.0; y <= 4.0; y += 1.0) {                    vec4 sample = texture2D(texture, texCoord + vec2(x, y) / texSize);                    float weight = 1.0 - abs(dot(sample.rgb - center.rgb, vec3(0.25)));                    weight = pow(weight, exponent);                    color += sample * weight;                    total += weight;                }            }            gl_FragColor = color / total;        }    ");for(var o=0;o<2;o++)f.call(this,e.denoise,{exponent:Math.max(0,t),texSize:[this.width,this.height]});return this}function z(t,o){return e.brightnessContrast=e.brightnessContrast||new h(null,"        uniform sampler2D texture;        uniform float brightness;        uniform float contrast;        varying vec2 texCoord;        void main() {            vec4 color = texture2D(texture, texCoord);            color.rgb += brightness;            if (contrast > 0.0) {                color.rgb = (color.rgb - 0.5) / (1.0 - contrast) + 0.5;            } else {                color.rgb = (color.rgb - 0.5) * (1.0 + contrast) + 0.5;            }            gl_FragColor = color;        }    "),f.call(this,e.brightnessContrast,{brightness:m(-1,t,1),contrast:m(-1,o,1)}),this}function I(t,o){return e.vignette=e.vignette||new h(null,"        uniform sampler2D texture;        uniform float size;        uniform float amount;        varying vec2 texCoord;        void main() {            vec4 color = texture2D(texture, texCoord);                        float dist = distance(texCoord, vec2(0.5, 0.5));            color.rgb *= smoothstep(0.8, size * 0.799, dist * (amount + size));                        gl_FragColor = color;        }    "),f.call(this,e.vignette,{size:m(0,t,1),amount:m(0,o,1)}),this}function X(t,o){return e.unsharpMask=e.unsharpMask||new h(null,"        uniform sampler2D blurredTexture;        uniform sampler2D originalTexture;        uniform float strength;        uniform float threshold;        varying vec2 texCoord;        void main() {            vec4 blurred = texture2D(blurredTexture, texCoord);            vec4 original = texture2D(originalTexture, texCoord);            gl_FragColor = mix(blurred, original, 1.0 + strength);        }    "),this._.extraTexture.ensureFormat(this._.texture),this._.texture.use(),this._.extraTexture.drawTo(function(){h.getDefaultShader().drawRect()}),this._.extraTexture.use(1),this.triangleBlur(t),e.unsharpMask.textures({originalTexture:1}),f.call(this,e.unsharpMask,{strength:o}),this._.extraTexture.unuse(1),this}function G(t,o){return e.hueSaturation=e.hueSaturation||new h(null,"        uniform sampler2D texture;        uniform float hue;        uniform float saturation;        varying vec2 texCoord;        void main() {            vec4 color = texture2D(texture, texCoord);                        /* hue adjustment, wolfram alpha: RotationTransform[angle, {1, 1, 1}][{x, y, z}] */            float angle = hue * 3.14159265;            float s = sin(angle), c = cos(angle);            vec3 weights = (vec3(2.0 * c, -sqrt(3.0) * s - c, sqrt(3.0) * s - c) + 1.0) / 3.0;            float len = length(color.rgb);            color.rgb = vec3(                dot(color.rgb, weights.xyz),                dot(color.rgb, weights.zxy),                dot(color.rgb, weights.yzx)            );                        /* saturation adjustment */            float average = (color.r + color.g + color.b) / 3.0;            if (saturation > 0.0) {                color.rgb += (average - color.rgb) * (1.0 - 1.0 / (1.001 - saturation));            } else {                color.rgb += (average - color.rgb) * (-saturation);            }                        gl_FragColor = color;        }    "),f.call(this,e.hueSaturation,{hue:m(-1,t,1),saturation:m(-1,o,1)}),this}function k(t){return e.vibrance=e.vibrance||new h(null,"        uniform sampler2D texture;        uniform float amount;        varying vec2 texCoord;        void main() {            vec4 color = texture2D(texture, texCoord);            float average = (color.r + color.g + color.b) / 3.0;            float mx = max(color.r, max(color.g, color.b));            float amt = (mx - average) * (-amount * 3.0);            color.rgb = mix(color.rgb, vec3(mx), amt);            gl_FragColor = color;        }    "),f.call(this,e.vibrance,{amount:m(-1,t,1)}),this}function w(t){for(var o=new S(t),a=[],i=0;i<256;i++)a.push(m(0,Math.floor(o.interpolate(i/255)*256),255));return a}function L(t,o,a){t=w(t),arguments.length==1?o=a=t:(o=w(o),a=w(a));for(var i=[],n=0;n<256;n++)i.splice(i.length,0,t[n],o[n],a[n],255);return this._.extraTexture.initFromBytes(256,1,i),this._.extraTexture.use(1),e.curves=e.curves||new h(null,"        uniform sampler2D texture;        uniform sampler2D map;        varying vec2 texCoord;        void main() {            vec4 color = texture2D(texture, texCoord);            color.r = texture2D(map, vec2(color.r)).r;            color.g = texture2D(map, vec2(color.g)).g;            color.b = texture2D(map, vec2(color.b)).b;            gl_FragColor = color;        }    "),e.curves.textures({map:1}),f.call(this,e.curves,{}),this}function M(t){return e.noise=e.noise||new h(null,"        uniform sampler2D texture;        uniform float amount;        varying vec2 texCoord;        float rand(vec2 co) {            return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);        }        void main() {            vec4 color = texture2D(texture, texCoord);                        float diff = (rand(texCoord) - 0.5) * amount;            color.r += diff;            color.g += diff;            color.b += diff;                        gl_FragColor = color;        }    "),f.call(this,e.noise,{amount:m(0,t,1)}),this}function O(t){return e.edgeWork1=e.edgeWork1||new h(null,"        uniform sampler2D texture;        uniform vec2 delta;        varying vec2 texCoord;        "+g+"        void main() {            vec2 color = vec2(0.0);            vec2 total = vec2(0.0);                        /* randomize the lookup values to hide the fixed number of samples */            float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);                        for (float t = -30.0; t <= 30.0; t++) {                float percent = (t + offset - 0.5) / 30.0;                float weight = 1.0 - abs(percent);                vec3 sample = texture2D(texture, texCoord + delta * percent).rgb;                float average = (sample.r + sample.g + sample.b) / 3.0;                color.x += average * weight;                total.x += weight;                if (abs(t) < 15.0) {                    weight = weight * 2.0 - 1.0;                    color.y += average * weight;                    total.y += weight;                }            }            gl_FragColor = vec4(color / total, 0.0, 1.0);        }    "),e.edgeWork2=e.edgeWork2||new h(null,"        uniform sampler2D texture;        uniform vec2 delta;        varying vec2 texCoord;        "+g+"        void main() {            vec2 color = vec2(0.0);            vec2 total = vec2(0.0);                        /* randomize the lookup values to hide the fixed number of samples */            float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);                        for (float t = -30.0; t <= 30.0; t++) {                float percent = (t + offset - 0.5) / 30.0;                float weight = 1.0 - abs(percent);                vec2 sample = texture2D(texture, texCoord + delta * percent).xy;                color.x += sample.x * weight;                total.x += weight;                if (abs(t) < 15.0) {                    weight = weight * 2.0 - 1.0;                    color.y += sample.y * weight;                    total.y += weight;                }            }            float c = clamp(10000.0 * (color.y / total.y - color.x / total.x) + 0.5, 0.0, 1.0);            gl_FragColor = vec4(c, c, c, 1.0);        }    "),f.call(this,e.edgeWork1,{delta:[t/this.width,0]}),f.call(this,e.edgeWork2,{delta:[0,t/this.height]}),this}function N(t){return e.ink=e.ink||new h(null,"        uniform sampler2D texture;        uniform float strength;        uniform vec2 texSize;        varying vec2 texCoord;        void main() {            vec2 dx = vec2(1.0 / texSize.x, 0.0);            vec2 dy = vec2(0.0, 1.0 / texSize.y);            vec4 color = texture2D(texture, texCoord);            float bigTotal = 0.0;            float smallTotal = 0.0;            vec3 bigAverage = vec3(0.0);            vec3 smallAverage = vec3(0.0);            for (float x = -2.0; x <= 2.0; x += 1.0) {                for (float y = -2.0; y <= 2.0; y += 1.0) {                    vec3 sample = texture2D(texture, texCoord + dx * x + dy * y).rgb;                    bigAverage += sample;                    bigTotal += 1.0;                    if (abs(x) + abs(y) < 2.0) {                        smallAverage += sample;                        smallTotal += 1.0;                    }                }            }            vec3 edge = max(vec3(0.0), bigAverage / bigTotal - smallAverage / smallTotal);            gl_FragColor = vec4(color.rgb - dot(edge, edge) * strength * 100000.0, color.a);        }    "),f.call(this,e.ink,{strength:t*t*t*t*t,texSize:[this.width,this.height]}),this}function W(t,o,a,i){return e.dotScreen=e.dotScreen||new h(null,"        uniform sampler2D texture;        uniform vec2 center;        uniform float angle;        uniform float scale;        uniform vec2 texSize;        varying vec2 texCoord;                float pattern() {            float s = sin(angle), c = cos(angle);            vec2 tex = texCoord * texSize - center;            vec2 point = vec2(                c * tex.x - s * tex.y,                s * tex.x + c * tex.y            ) * scale;            return (sin(point.x) * sin(point.y)) * 4.0;        }                void main() {            vec4 color = texture2D(texture, texCoord);            float average = (color.r + color.g + color.b) / 3.0;            gl_FragColor = vec4(vec3(average * 10.0 - 5.0 + pattern()), color.a);        }    "),f.call(this,e.dotScreen,{center:[t,o],angle:a,scale:Math.PI/i,texSize:[this.width,this.height]}),this}function Y(t,o,a){return e.hexagonalPixelate=e.hexagonalPixelate||new h(null,"        uniform sampler2D texture;        uniform vec2 center;        uniform float scale;        uniform vec2 texSize;        varying vec2 texCoord;        void main() {            vec2 tex = (texCoord * texSize - center) / scale;            tex.y /= 0.866025404;            tex.x -= tex.y * 0.5;                        vec2 a;            if (tex.x + tex.y - floor(tex.x) - floor(tex.y) < 1.0) a = vec2(floor(tex.x), floor(tex.y));            else a = vec2(ceil(tex.x), ceil(tex.y));            vec2 b = vec2(ceil(tex.x), floor(tex.y));            vec2 c = vec2(floor(tex.x), ceil(tex.y));                        vec3 TEX = vec3(tex.x, tex.y, 1.0 - tex.x - tex.y);            vec3 A = vec3(a.x, a.y, 1.0 - a.x - a.y);            vec3 B = vec3(b.x, b.y, 1.0 - b.x - b.y);            vec3 C = vec3(c.x, c.y, 1.0 - c.x - c.y);                        float alen = length(TEX - A);            float blen = length(TEX - B);            float clen = length(TEX - C);                        vec2 choice;            if (alen < blen) {                if (alen < clen) choice = a;                else choice = c;            } else {                if (blen < clen) choice = b;                else choice = c;            }                        choice.x += choice.y * 0.5;            choice.y *= 0.866025404;            choice *= scale / texSize;            gl_FragColor = texture2D(texture, choice + center / texSize);        }    "),f.call(this,e.hexagonalPixelate,{center:[t,o],scale:a,texSize:[this.width,this.height]}),this}function H(t,o,a,i){return e.colorHalftone=e.colorHalftone||new h(null,"        uniform sampler2D texture;        uniform vec2 center;        uniform float angle;        uniform float scale;        uniform vec2 texSize;        varying vec2 texCoord;                float pattern(float angle) {            float s = sin(angle), c = cos(angle);            vec2 tex = texCoord * texSize - center;            vec2 point = vec2(                c * tex.x - s * tex.y,                s * tex.x + c * tex.y            ) * scale;            return (sin(point.x) * sin(point.y)) * 4.0;        }                void main() {            vec4 color = texture2D(texture, texCoord);            vec3 cmy = 1.0 - color.rgb;            float k = min(cmy.x, min(cmy.y, cmy.z));            cmy = (cmy - k) / (1.0 - k);            cmy = clamp(cmy * 10.0 - 3.0 + vec3(pattern(angle + 0.26179), pattern(angle + 1.30899), pattern(angle)), 0.0, 1.0);            k = clamp(k * 10.0 - 5.0 + pattern(angle + 0.78539), 0.0, 1.0);            gl_FragColor = vec4(1.0 - cmy - k, color.a);        }    "),f.call(this,e.colorHalftone,{center:[t,o],angle:a,scale:Math.PI/i,texSize:[this.width,this.height]}),this}function j(t,o,a){return e.zoomBlur=e.zoomBlur||new h(null,"        uniform sampler2D texture;        uniform vec2 center;        uniform float strength;        uniform vec2 texSize;        varying vec2 texCoord;        "+g+"        void main() {            vec4 color = vec4(0.0);            float total = 0.0;            vec2 toCenter = center - texCoord * texSize;                        /* randomize the lookup values to hide the fixed number of samples */            float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);                        for (float t = 0.0; t <= 40.0; t++) {                float percent = (t + offset) / 40.0;                float weight = 4.0 * (percent - percent * percent);                vec4 sample = texture2D(texture, texCoord + toCenter * percent * strength / texSize);                                /* switch to pre-multiplied alpha to correctly blur transparent images */                sample.rgb *= sample.a;                                color += sample * weight;                total += weight;            }                        gl_FragColor = color / total;                        /* switch back from pre-multiplied alpha */            gl_FragColor.rgb /= gl_FragColor.a + 0.00001;        }    "),f.call(this,e.zoomBlur,{center:[t,o],strength:a,texSize:[this.width,this.height]}),this}function V(t,o,a,i,n,u){e.tiltShift=e.tiltShift||new h(null,"        uniform sampler2D texture;        uniform float blurRadius;        uniform float gradientRadius;        uniform vec2 start;        uniform vec2 end;        uniform vec2 delta;        uniform vec2 texSize;        varying vec2 texCoord;        "+g+"        void main() {            vec4 color = vec4(0.0);            float total = 0.0;                        /* randomize the lookup values to hide the fixed number of samples */            float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);                        vec2 normal = normalize(vec2(start.y - end.y, end.x - start.x));            float radius = smoothstep(0.0, 1.0, abs(dot(texCoord * texSize - start, normal)) / gradientRadius) * blurRadius;            for (float t = -30.0; t <= 30.0; t++) {                float percent = (t + offset - 0.5) / 30.0;                float weight = 1.0 - abs(percent);                vec4 sample = texture2D(texture, texCoord + delta / texSize * percent * radius);                                /* switch to pre-multiplied alpha to correctly blur transparent images */                sample.rgb *= sample.a;                                color += sample * weight;                total += weight;            }                        gl_FragColor = color / total;                        /* switch back from pre-multiplied alpha */            gl_FragColor.rgb /= gl_FragColor.a + 0.00001;        }    ");var l=a-t,s=i-o,r=Math.sqrt(l*l+s*s);return f.call(this,e.tiltShift,{blurRadius:n,gradientRadius:u,start:[t,o],end:[a,i],delta:[l/r,s/r],texSize:[this.width,this.height]}),f.call(this,e.tiltShift,{blurRadius:n,gradientRadius:u,start:[t,o],end:[a,i],delta:[-s/r,l/r],texSize:[this.width,this.height]}),this}function $(t){return e.triangleBlur=e.triangleBlur||new h(null,"        uniform sampler2D texture;        uniform vec2 delta;        varying vec2 texCoord;        "+g+"        void main() {            vec4 color = vec4(0.0);            float total = 0.0;                        /* randomize the lookup values to hide the fixed number of samples */            float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);                        for (float t = -30.0; t <= 30.0; t++) {                float percent = (t + offset - 0.5) / 30.0;                float weight = 1.0 - abs(percent);                vec4 sample = texture2D(texture, texCoord + delta * percent);                                /* switch to pre-multiplied alpha to correctly blur transparent images */                sample.rgb *= sample.a;                                color += sample * weight;                total += weight;            }                        gl_FragColor = color / total;                        /* switch back from pre-multiplied alpha */            gl_FragColor.rgb /= gl_FragColor.a + 0.00001;        }    "),f.call(this,e.triangleBlur,{delta:[t/this.width,0]}),f.call(this,e.triangleBlur,{delta:[0,t/this.height]}),this}function q(t,o,a){e.lensBlurPrePass=e.lensBlurPrePass||new h(null,"        uniform sampler2D texture;        uniform float power;        varying vec2 texCoord;        void main() {            vec4 color = texture2D(texture, texCoord);            color = pow(color, vec4(power));            gl_FragColor = vec4(color);        }    ");var i="        uniform sampler2D texture0;        uniform sampler2D texture1;        uniform vec2 delta0;        uniform vec2 delta1;        uniform float power;        varying vec2 texCoord;        "+g+"        vec4 sample(vec2 delta) {            /* randomize the lookup values to hide the fixed number of samples */            float offset = random(vec3(delta, 151.7182), 0.0);                        vec4 color = vec4(0.0);            float total = 0.0;            for (float t = 0.0; t <= 30.0; t++) {                float percent = (t + offset) / 30.0;                color += texture2D(texture0, texCoord + delta * percent);                total += 1.0;            }            return color / total;        }    ";e.lensBlur0=e.lensBlur0||new h(null,i+"        void main() {            gl_FragColor = sample(delta0);        }    "),e.lensBlur1=e.lensBlur1||new h(null,i+"        void main() {            gl_FragColor = (sample(delta0) + sample(delta1)) * 0.5;        }    "),e.lensBlur2=e.lensBlur2||new h(null,i+"        void main() {            vec4 color = (sample(delta0) + 2.0 * texture2D(texture1, texCoord)) / 3.0;            gl_FragColor = pow(color, vec4(power));        }    ").textures({texture1:1});for(var n=[],u=0;u<3;u++){var l=a+u*Math.PI*2/3;n.push([t*Math.sin(l)/this.width,t*Math.cos(l)/this.height])}var s=Math.pow(10,m(-1,o,1));return f.call(this,e.lensBlurPrePass,{power:s}),this._.extraTexture.ensureFormat(this._.texture),f.call(this,e.lensBlur0,{delta0:n[0]},this._.texture,this._.extraTexture),f.call(this,e.lensBlur1,{delta0:n[1],delta1:n[2]},this._.extraTexture,this._.extraTexture),f.call(this,e.lensBlur0,{delta0:n[1]}),this._.extraTexture.use(1),f.call(this,e.lensBlur2,{power:1/s,delta0:n[2]}),this}function K(t,o,a){if(e.matrixWarp=e.matrixWarp||C("        uniform mat3 matrix;        uniform bool useTextureSpace;    ","        if (useTextureSpace) coord = coord / texSize * 2.0 - 1.0;        vec3 warp = matrix * vec3(coord, 1.0);        coord = warp.xy / warp.z;        if (useTextureSpace) coord = (coord * 0.5 + 0.5) * texSize;    "),t=Array.prototype.concat.apply([],t),t.length==4)t=[t[0],t[1],0,t[2],t[3],0,0,0,1];else if(t.length!=9)throw"can only warp with 2x2 or 3x3 matrix";return f.call(this,e.matrixWarp,{matrix:o?F(t):t,texSize:[this.width,this.height],useTextureSpace:a|0}),this}function Q(t,o,a,i){return e.bulgePinch=e.bulgePinch||C("        uniform float radius;        uniform float strength;        uniform vec2 center;    ","        coord -= center;        float distance = length(coord);        if (distance < radius) {            float percent = distance / radius;            if (strength > 0.0) {                coord *= mix(1.0, smoothstep(0.0, radius / distance, percent), strength * 0.75);            } else {                coord *= mix(1.0, pow(percent, 1.0 + strength * 0.75) * radius / distance, 1.0 - percent);            }        }        coord += center;    "),f.call(this,e.bulgePinch,{radius:a,strength:m(-1,i,1),center:[t,o],texSize:[this.width,this.height]}),this}function J(t,o){var a=D.apply(null,o),i=D.apply(null,t),n=ee(F(a),i);return this.matrixWarp(n)}function Z(t,o,a,i){return e.swirl=e.swirl||C("        uniform float radius;        uniform float angle;        uniform vec2 center;    ","        coord -= center;        float distance = length(coord);        if (distance < radius) {            float percent = (radius - distance) / radius;            float theta = percent * percent * angle;            float s = sin(theta);            float c = cos(theta);            coord = vec2(                coord.x * c - coord.y * s,                coord.x * s + coord.y * c            );        }        coord += center;    "),f.call(this,e.swirl,{radius:a,center:[t,o],angle:i,texSize:[this.width,this.height]}),this}function S(t){var o=t.length;this.xa=[],this.ya=[],this.u=[],this.y2=[],t.sort(function(s,r){return s[0]-r[0]});for(var a=0;a<o;a++)this.xa.push(t[a][0]),this.ya.push(t[a][1]);this.u[0]=0,this.y2[0]=0;for(var a=1;a<o-1;++a){var i=this.xa[a+1]-this.xa[a-1],n=(this.xa[a]-this.xa[a-1])/i,u=n*this.y2[a-1]+2;this.y2[a]=(n-1)/u;var l=(this.ya[a+1]-this.ya[a])/(this.xa[a+1]-this.xa[a])-(this.ya[a]-this.ya[a-1])/(this.xa[a]-this.xa[a-1]);this.u[a]=(6*l/i-n*this.u[a-1])/u}this.y2[o-1]=0;for(var a=o-2;a>=0;--a)this.y2[a]=this.y2[a]*this.y2[a+1]+this.u[a]}S.prototype.interpolate=function(t){for(var o=this.ya.length,a=0,i=o-1;i-a>1;){var n=i+a>>1;this.xa[n]>t?i=n:a=n}var u=this.xa[i]-this.xa[a],l=(this.xa[i]-t)/u,s=(t-this.xa[a])/u;return l*this.ya[a]+s*this.ya[i]+((l*l*l-l)*this.y2[a]+(s*s*s-s)*this.y2[i])*(u*u)/6};function D(t,o,a,i,n,u,l,s){var r=a-n,c=i-u,d=l-n,b=s-u,E=t-a+n-l,v=o-i+u-s,_=r*b-d*c,p=(E*b-d*v)/_,y=(r*v-E*c)/_;return[a-t+p*a,i-o+p*i,p,l-t+y*l,s-o+y*s,y,t,o,1]}function F(t){var o=t[0],a=t[1],i=t[2],n=t[3],u=t[4],l=t[5],s=t[6],r=t[7],c=t[8],d=o*u*c-o*l*r-a*n*c+a*l*s+i*n*r-i*u*s;return[(u*c-l*r)/d,(i*r-a*c)/d,(a*l-i*u)/d,(l*s-n*c)/d,(o*c-i*s)/d,(i*n-o*l)/d,(n*r-u*s)/d,(a*s-o*r)/d,(o*u-a*n)/d]}function ee(t,o){return[t[0]*o[0]+t[1]*o[3]+t[2]*o[6],t[0]*o[1]+t[1]*o[4]+t[2]*o[7],t[0]*o[2]+t[1]*o[5]+t[2]*o[8],t[3]*o[0]+t[4]*o[3]+t[5]*o[6],t[3]*o[1]+t[4]*o[4]+t[5]*o[7],t[3]*o[2]+t[4]*o[5]+t[5]*o[8],t[6]*o[0]+t[7]*o[3]+t[8]*o[6],t[6]*o[1]+t[7]*o[4]+t[8]*o[7],t[6]*o[2]+t[7]*o[5]+t[8]*o[8]]}var h=function(){function t(l){return Object.prototype.toString.call(l)=="[object Array]"}function o(l){return Object.prototype.toString.call(l)=="[object Number]"}function a(l,s){var r=e.createShader(l);if(e.shaderSource(r,s),e.compileShader(r),!e.getShaderParameter(r,e.COMPILE_STATUS))throw"compile error: "+e.getShaderInfoLog(r);return r}var i="    attribute vec2 vertex;    attribute vec2 _texCoord;    varying vec2 texCoord;    void main() {        texCoord = _texCoord;        gl_Position = vec4(vertex * 2.0 - 1.0, 0.0, 1.0);    }",n="    uniform sampler2D texture;    varying vec2 texCoord;    void main() {        gl_FragColor = texture2D(texture, texCoord);    }";function u(l,s){if(this.vertexAttribute=null,this.texCoordAttribute=null,this.program=e.createProgram(),l=l||i,s=s||n,s="precision highp float;"+s,e.attachShader(this.program,a(e.VERTEX_SHADER,l)),e.attachShader(this.program,a(e.FRAGMENT_SHADER,s)),e.linkProgram(this.program),!e.getProgramParameter(this.program,e.LINK_STATUS))throw"link error: "+e.getProgramInfoLog(this.program)}return u.prototype.destroy=function(){e.deleteProgram(this.program),this.program=null},u.prototype.uniforms=function(l){e.useProgram(this.program);for(var s in l)if(!!l.hasOwnProperty(s)){var r=e.getUniformLocation(this.program,s);if(r!==null){var c=l[s];if(t(c))switch(c.length){case 1:e.uniform1fv(r,new Float32Array(c));break;case 2:e.uniform2fv(r,new Float32Array(c));break;case 3:e.uniform3fv(r,new Float32Array(c));break;case 4:e.uniform4fv(r,new Float32Array(c));break;case 9:e.uniformMatrix3fv(r,!1,new Float32Array(c));break;case 16:e.uniformMatrix4fv(r,!1,new Float32Array(c));break;default:throw`dont't know how to load uniform "`+s+'" of length '+c.length}else if(o(c))e.uniform1f(r,c);else throw'attempted to set uniform "'+s+'" to invalid value '+(c||"undefined").toString()}}return this},u.prototype.textures=function(l){e.useProgram(this.program);for(var s in l)!l.hasOwnProperty(s)||e.uniform1i(e.getUniformLocation(this.program,s),l[s]);return this},u.prototype.drawRect=function(l,s,r,c){var d;s=s!==d?s/e.drawingBufferHeight:0,l=l!==d?l/e.drawingBufferWidth:0,r=r!==d?r/e.drawingBufferWidth:1,c=c!==d?c/e.drawingBufferWidth:1,e.vertexBuffer==null&&(e.vertexBuffer=e.createBuffer()),e.bindBuffer(e.ARRAY_BUFFER,e.vertexBuffer),e.bufferData(e.ARRAY_BUFFER,new Float32Array([l,s,l,c,r,s,r,c]),e.STATIC_DRAW),e.texCoordBuffer==null&&(e.texCoordBuffer=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,e.texCoordBuffer),e.bufferData(e.ARRAY_BUFFER,new Float32Array([0,0,0,1,1,0,1,1]),e.STATIC_DRAW)),this.vertexAttribute==null&&(this.vertexAttribute=e.getAttribLocation(this.program,"vertex"),e.enableVertexAttribArray(this.vertexAttribute)),this.texCoordAttribute==null&&(this.texCoordAttribute=e.getAttribLocation(this.program,"_texCoord"),e.enableVertexAttribArray(this.texCoordAttribute)),e.useProgram(this.program),e.bindBuffer(e.ARRAY_BUFFER,e.vertexBuffer),e.vertexAttribPointer(this.vertexAttribute,2,e.FLOAT,!1,0,0),e.bindBuffer(e.ARRAY_BUFFER,e.texCoordBuffer),e.vertexAttribPointer(this.texCoordAttribute,2,e.FLOAT,!1,0,0),e.drawArrays(e.TRIANGLE_STRIP,0,4)},u.getDefaultShader=function(){return e.defaultShader=e.defaultShader||new u,e.defaultShader},u}(),e;function m(t,o,a){return Math.max(t,Math.min(o,a))}function B(t){return{_:t,loadContentsOf:function(o){e=this._.gl,this._.loadContentsOf(o)},destroy:function(){e=this._.gl,this._.destroy()}}}function te(t){return B(T.fromElement(t))}function re(t,o){var a=e.UNSIGNED_BYTE;if(e.getExtension("OES_texture_float")&&e.getExtension("OES_texture_float_linear")){var i=new T(100,100,e.RGBA,e.FLOAT);try{i.drawTo(function(){a=e.FLOAT})}catch{}i.destroy()}this._.texture&&this._.texture.destroy(),this._.spareTexture&&this._.spareTexture.destroy(),this.width=t,this.height=o,this._.texture=new T(t,o,e.RGBA,a),this._.spareTexture=new T(t,o,e.RGBA,a),this._.extraTexture=this._.extraTexture||new T(0,0,e.RGBA,a),this._.flippedShader=this._.flippedShader||new h(null,"        uniform sampler2D texture;        varying vec2 texCoord;        void main() {            gl_FragColor = texture2D(texture, vec2(texCoord.x, 1.0 - texCoord.y));        }    "),this._.isInitialized=!0}function oe(t,o,a){return(!this._.isInitialized||t._.width!=this.width||t._.height!=this.height)&&re.call(this,o||t._.width,a||t._.height),t._.use(),this._.texture.drawTo(function(){h.getDefaultShader().drawRect()}),this}function ae(){return this._.texture.use(),this._.flippedShader.drawRect(),this}function f(t,o,a,i){(a||this._.texture).use(),this._.spareTexture.drawTo(function(){t.uniforms(o).drawRect()}),this._.spareTexture.swapWith(i||this._.texture)}function ie(t){return t.parentNode.insertBefore(this,t),t.parentNode.removeChild(t),this}function ne(){var t=new T(this._.texture.width,this._.texture.height,e.RGBA,e.UNSIGNED_BYTE);return this._.texture.use(),t.drawTo(function(){h.getDefaultShader().drawRect()}),B(t)}function le(){var t=this._.texture.width,o=this._.texture.height,a=new Uint8Array(t*o*4);return this._.texture.drawTo(function(){e.readPixels(0,0,t,o,e.RGBA,e.UNSIGNED_BYTE,a)}),a}function x(t){return function(){return e=this._.gl,t.apply(this,arguments)}}R.canvas=function(){var t=document.createElement("canvas");try{e=t.getContext("webgl2",{premultipliedAlpha:!1})}catch{e=null}if(!e)throw"This browser does not support WebGL";return t._={gl:e,isInitialized:!1,texture:null,spareTexture:null,flippedShader:null},t.texture=x(te),t.draw=x(oe),t.update=x(ae),t.replace=x(ie),t.contents=x(ne),t.getPixelArray=x(le),t.brightnessContrast=x(z),t.hexagonalPixelate=x(Y),t.hueSaturation=x(G),t.colorHalftone=x(H),t.triangleBlur=x($),t.unsharpMask=x(X),t.perspective=x(J),t.matrixWarp=x(K),t.bulgePinch=x(Q),t.tiltShift=x(V),t.dotScreen=x(W),t.edgeWork=x(O),t.lensBlur=x(q),t.zoomBlur=x(j),t.noise=x(M),t.denoise=x(P),t.curves=x(L),t.swirl=x(Z),t.ink=x(N),t.vignette=x(I),t.vibrance=x(k),t.sepia=x(U),t},R.splineInterpolate=w;var T=function(){t.fromElement=function(i){var n=new t(0,0,e.RGBA,e.UNSIGNED_BYTE);return n.loadContentsOf(i),n};function t(i,n,u,l){this.gl=e,this.id=e.createTexture(),this.width=i,this.height=n,this.format=u,this.type=l,e.bindTexture(e.TEXTURE_2D,this.id),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,e.LINEAR),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.LINEAR),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE),i&&n&&e.texImage2D(e.TEXTURE_2D,0,this.format,i,n,0,this.format,this.type,null)}t.prototype.loadContentsOf=function(i){this.width=i.width||i.videoWidth,this.height=i.height||i.videoHeight,e.bindTexture(e.TEXTURE_2D,this.id),e.texImage2D(e.TEXTURE_2D,0,this.format,this.format,this.type,i)},t.prototype.initFromBytes=function(i,n,u){this.width=i,this.height=n,this.format=e.RGBA,this.type=e.UNSIGNED_BYTE,e.bindTexture(e.TEXTURE_2D,this.id),e.texImage2D(e.TEXTURE_2D,0,e.RGBA,i,n,0,e.RGBA,this.type,new Uint8Array(u))},t.prototype.destroy=function(){e.deleteTexture(this.id),this.id=null},t.prototype.use=function(i){e.activeTexture(e.TEXTURE0+(i||0)),e.bindTexture(e.TEXTURE_2D,this.id)},t.prototype.unuse=function(i){e.activeTexture(e.TEXTURE0+(i||0)),e.bindTexture(e.TEXTURE_2D,null)},t.prototype.ensureFormat=function(i,n,u,l){if(arguments.length==1){var s=arguments[0];i=s.width,n=s.height,u=s.format,l=s.type}(i!=this.width||n!=this.height||u!=this.format||l!=this.type)&&(this.width=i,this.height=n,this.format=u,this.type=l,e.bindTexture(e.TEXTURE_2D,this.id),e.texImage2D(e.TEXTURE_2D,0,this.format,i,n,0,this.format,this.type,null))},t.prototype.drawTo=function(i){e.framebuffer=e.framebuffer||e.createFramebuffer(),e.bindFramebuffer(e.FRAMEBUFFER,e.framebuffer),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,this.id,0),e.viewport(0,0,this.width,this.height),i(),e.bindFramebuffer(e.FRAMEBUFFER,null)};var o=null;function a(i){o==null&&(o=document.createElement("canvas")),o.width=i.width,o.height=i.height;var n=o.getContext("2d");return n.clearRect(0,0,o.width,o.height),n}return t.prototype.fillUsingCanvas=function(i){return i(a(this)),this.format=e.RGBA,this.type=e.UNSIGNED_BYTE,e.bindTexture(e.TEXTURE_2D,this.id),e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,o),this},t.prototype.toImage=function(i){this.use(),h.getDefaultShader().drawRect();var n=this.width*this.height*4,u=new Uint8Array(n),l=a(this),s=l.createImageData(this.width,this.height);e.readPixels(0,0,this.width,this.height,e.RGBA,e.UNSIGNED_BYTE,u);for(var r=0;r<n;r++)s.data[r]=u[r];l.putImageData(s,0,0),i.src=o.toDataURL()},t.prototype.swapWith=function(i){var n;n=i.id,i.id=this.id,this.id=n,n=i.width,i.width=this.width,this.width=n,n=i.height,i.height=this.height,this.height=n,n=i.format,i.format=this.format,this.format=n},t}();return R}();
